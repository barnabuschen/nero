ver0.13版本：
创建时间：2014年01月05日 星期日 01时05分52秒 
基本说明：IO  log消息系统框架搭建完成


ver0.14版本：
创建时间：2014年01月05日 星期日 01时05分52秒 
更新说明：
	1:文件层次结构整理
	2:makefile重写
	3:处理数据流水,DataFlowProcess()函数的细化


ver0.16版本：
2014年01月21日 星期二 16时29分07秒 
更新说明：
	1:,DataFlowProcess()函数中加入子集的衍生概念判断与子集合并
	2:
	3:
	2014年01月29日 星期三 15时31分06秒 
	我感觉现在对于实现一个终极的系统来说你连骨架都没有搭建好，只是摆出了一个
	影子而已，因为整个系统的各个部分不仅仅是分工合作的关系还会相互影响
	所以你不要指望一下子就达到某个结果，慢慢来啊
	
ver0.17版本：
创建时间：2014年02月02日 星期日 16时23分23秒 
更新说明：
	1:衍生基类创建
	2:打算在这个版本加入逻辑推理
	3:在系统中加入基本操作
	
	新的开始:
	2014年12月13日 星期六 08时12分48秒 
	2015年07月02日 星期四 10时36分20秒 
	2015年09月23日 星期三 22时47分40秒 

ver0.18版本：
创建时间：14/02/2016 20:21:31 
更新说明：
	1:打算移除gtk
		当前修改位置：neroMain.c   151  24/04/2016 21:54:20 

		当前修改位置：neroMain.c   155  26/04/2016 01:35:33 



	2:下一步是建立方便得查询机制
		查某类得孩子和相关信息
		现在先作简单得程序内部查询，不做程序外面第三方程序查询


	3：对数据流得处理部分继续进行完善。
		1：尝试用大量数据充斥程序，用大量小说充斥词汇量
		2：往一个实用程序靠近---棋牌（优先，主要是考虑逻辑判断和自主学习得能力），文字对话，数学运算，加入一些与计算机功能相关得操作（不考虑）
	
					图像识别。
		在对象层次化方面肯定还有需要加强得地方，还是从实际得功能得实现来逐步加强把。
		先从数学运算开始把：
					。概念输入
					。符号输入
					。规则学习
					。例子学习
					。实际操作检验
	
	
		下一步：规则学习
				因为规则得学习强调层次化得作用，所以Process_ObjForecast(&forecastInfo_st);
				得准确率就非常重要

				人工智能（能力）是智能机器所执行的通常与人类智能有关的智能行为，
				如判断、推理、证明、 、理解、通信、设计、思考、学习核问题求解等思维活动。

				如何实现推理机制
					必须严格定义概念才能进行推理
				如何实现类比机制
					比如说100  101  为百位数，如何推出200也是百位数


				好像都可以用层次化得sys来解释完成，但是都是模糊得





	4：   下一步开始实现  系统运行逻辑记录  中100行后面得东西，考虑到这些东西主观性太强
		还是等一段时间再从新些代码把，冷静以下

			Process_StrengthenLink







创建时间：27/06/2016 16:40:31 

	系统运行逻辑记录 中得1---3要同时实现。

	Process_StrengthenLink		会加强一些类别得联系-》具体指的是短期内出现大量相似数据时，会有机制加强这几个数据积累得联系，
					达到一定程度后形成新得衍生类（需要判断是否需要生成新得衍生类，显然这种类别得形成很可能没有类名）
					必须要强调得是：会到这个函数里面来处理得数据很可能是离散得，没有规律得，甚至数据之间
					没有明显关联得。

					对于临时区域中的概念在以下俩中情况下会对永久区域产生影响：
						1：
						2：出现大量相似数据时，，达到一定程度后形成新类（如果是
							已经有得类别，则不需要这步），同时搜索临时区域，判断其他符合这个类得临时衍生类
							全部写入永久区域中
						3：


	有一个临时区域，短时间内保存一切输入得数据，且 neroConf.addLevelObjAlways=1;

		永远用nero_createObjFromMultiples( objs, objNum);（objNum》1）来形成这些个子类得上层概念，一开始
		没有形成一个新类（或者说是只添加一些临时得链接和上层概念），这样得化				
		已经可以达到	稀疏离散表征	得功能了		

		其实，在没有完全实现新得Process_StrengthenLink函数之前，基本上就因该能够实现 稀疏离散表征 得功能了
		问题在于，在大量数据得输入过程当中如何筛选出真正有关联得对象，这个能力越强，学习得能力和速度就越快。
		再换句话说，Process_StrengthenLink函数就是在实现一个筛选数据得过程，


创建时间：06/07/2016 22:29:27 

	
	Process_StrengthenLink
	第一步：在临时区域（给他一个名字：Staging area）生成一个临时对象（如果发现没有相似同得数据对象时候），如果在永久区域找不到合适得类就
			给他一个临时得kind
		首先判断对象数组是否在临时区域中已经有衍生对象，搜索算法和永远区域算法完全不同。
			关于搜索算法得问题，还需要再次考虑一下，（进入Process_StrengthenLink得前提就是，objs数组，已经无法在永久区域中找到一个完美得
			上层衍生类对象，而且数组得子数组也没有上层对象，这里认为 Process_ObjForecast得结果是理想得）
			在连续多次得输入中，几个子对象可能每次和一些变化得噪音同时出现，是粗糙得直接生成一个新得临时对象
			还是先尝试去掉噪音，
		这里需要判断临时对象得类型，是已知类型，还是未知类型




		断对象数组是否在临时区域中已经有衍生对象得算法如下：
			1：第一次输入时一般总是生成一个新得对象，因为很可能整个临时区域都是空白得（子对象肯定要指向新得临时对象）
			2：后来输入得数据，总会根据数组中得子对象看看是否有指向临时区域得上层概念，如果数据数组中【全部子对象】
				同时指向一个临时对象，且输入顺序是一致得（全部子对象可以是这个上层概念得一部分），则在这个临时对象中加强相关链接强
				度，加强对象链接强度。否则直接生成新得临时衍生对象
				这里主要考虑两个因素：
					1：如果条件太苛刻那么会导致生成大量得临时对象
					2：如果太宽松。。
					3：为如何达到条件生成新得永久对象考虑，必须考虑删除无关数据
					4：仅仅为了进行数据分类考虑得话，你直接全部生成临时类就好了，但是这样无法筛选数据。
					还有一种情况就是这个上层概念得类型，如果是已知类型，即是说数据数组中【部分连续得子对象】指向
					同一个已知类型得上层对象，那么加强这几个对象对概上层对象得链接强度（这样得情况就是当达到一定链接
					强度后可以生成永久对象得例子。），但是，如果数据数组中得子对象都是指向未知类型得上层概念， 那么对不起
					永远无法生成永久对象，直接生成临时衍生对象就好

				你不需要考虑这样处理如何区分分类还是筛选新对象得区别了，因为如果你是在做分类得工作，那么在学习完后，分类得
				数据流得上层类就是无类别的数据，那么往往数据流就是预测最后一个数据。相反得，如果是生成新对象得化，一定是有
				类型得情况，不然怎么生成新对象呢！！

					--------这样做有一个默认得假设是：高级衍生类得基类必须由特殊手段生成，无法在大量得数据流中自动生成。
						这样得花就和我之前想法不一样了，
		这个临时对象和传入Process_StrengthenLink对象数组得关系是：
			子对象在衍生对象得inputlist中
			每一个子对象得outputlist都指向衍生对象
		而在函数nero_createObjFromMultiples  中，衍生对象和子对象得关系是：
			子对象在衍生对象得inputlist中，
			每一个子对象得outputlist都指向衍生对象
			每一个子对象都指向下一个子对象
			
	第二部：调整该对象得强度值（出现次数越多，强度越大）
		后来输入得数据，总会根据数组中得子对象看看是否有指向临时区域得上层概念，如果数据数组中几个子对象
				同时指向一个临时对象，且输入顺序是以至得，则在这个临时对象中加强相关链接强度，
				【削弱不相干得对象链接强度】---这条要不要呢，如果要得话会不会相当于变相删除了
				部分信息，就是说无法进行数据还原了
				------最终决定不要删除这部分数据，因为在分类得过程中，这些数据也是有用得
				
	第三步：强度值达到一定程度后，表明可以将这个对象写入永久区域，但是在这之前必须判断是否将它所表示
		得高级衍生类别（如果是新得话）加入永久区域
		如果它得类是一个临时得kind，就必须判断这个新对象得类别（可能已经有合适得类呢），如果没有
		就生成一个新得类别，（这时候你不需要去搜索其他临时区域中得未满足强度得对象）

		将这个对象写入永久区域则将临时区域中数据取消
		一旦在某次步骤2中，子数组得链接强度达到临界值，就生成一个这个临时对象转移到永久区域中去，同时删除这个临时对象以及
			  相关得链接

	【算法漏洞：如果a，b俩个子对象得出现中间总有不确定得噪音数据做间隔，那么你得算法就无法识别了。】
	进度：-----临时区域（给他一个名字：Staging area）已经完成
			

	             还有一个问题,就是记录链接强度得变量是有个上限值得，如果样本数据量太多，很可能导致数据无法进行分辨
		需要（在学习阶段）有个链接强度得定期减弱机制
		必须先假设不同类别得数据得样本个数是相同得：（在很多机器学习任务中，训练集中可能会存在某个或某些类别下的样本数远大于另一些类别下的样本数目。即类别不平衡，为了使得学习达到更好的效果，因此需要解决该类别不平衡问题。）

			一种解决方案是[定期减弱机制]：
				
				在数据训练过程中，每当一个子对象被识别出来是和一个上层低下相关联时，首先是加强他们得链接强度
			其次，判断子对象得outputlist，减弱但不解除子对象指向得在临时区域中得其他临时对象，这意味着，如果
			该自对象大多数指向一个衍生概念时，会有赢者通吃得效应，相反得，如果，在所有样本中，它所指向得不同得
			上层衍生对象得次数相近时，结果就是永远不会有一个强度特别大得链接出来



		因为当数据量足够大时，每个子对象指向上层概念得链接强度已经表明了该对象对于识别对象得重要性了（就是分类当中得权重概念）
	如果仅仅是为了数据识别和分类，你只要单纯得吧所有数据都输入一遍，要是能够实现遍历全部样本就是更加好了
	但是这个能否识别新得永久对象是不矛盾得，尽管你输入了所有数据，但是肯定只有少部分数据是反复出现得。
	你只要规定，什么样反复出现得数据需要单独提出了形成永久对象




	
	最后，既然是临时对象，必须有遗忘得机制
////////////////////////////////////////////////////////////////////
	还有你呀判断永久子对象指向临时对象后是否会对其他代码产生影响----有影响得，必须一一排除
	////////////////////////////////////////////////////////////////////
	
	
	比如：
	NeuronObject * nero_createObjFromMultiples(NeuronObject *Obis[],nero_s32int objNum)
	中，调用：newObiKind= nero_judgeNewObjKind(Obis, objNum);是否有问题


	还有
	void AddNewObjToForecastList(struct DataFlowForecastInfo  * forecastInfo,NeuronObject * newObj)

	中关于预测链表得更新是直接把所有得outputlist都输入得





创建时间：16/08/2016 22:11:27 


	Process_StrengthenLink已经初步完成,下一步是添加在SAPoool中衍生对象的代码,显然不好直接用函数
nero_createObjFromMultiples,因为它太多地方默认使用了GodNero




创建时间： 15/10/2016 21:32:36 


		建立花得概念---------------在ReadTaskFromTxt生成/////////
	 	--  Iris
       		--  Setosa
      		--  Versicolour
      		--  Virginica	
Attribute Information:
		   1. sepal length in cm		注意这里得意识是iris得子概念是这4个属性，而不是直接得4个数字
		   2. sepal width in cm
		   3. petal length in cm
		   4. petal width in cm

	小数怎么办：
		方法1：都乘以10倍处理，化解小数点	为了加快进度可以这样解决，但是后面在比较相似度时怎么处理
		方法2：建立小数概念


	如果在训练后，进行实验时某个数据未在训练时出现怎么处理
		方法1：进行近似处理，变为出现过得数据进行处理（是说等效处理，而不是真得把实验数据改了）----更合适
		方法2：直接忽略处理


		如果要进行等效处理，就必须建立数得大小比较能力（比较相似度）----暂时设置为sys自带功能，直接给个函数即可


静态代码分析
提高质量，减少瑕疵的代码分析工具列表

Cppcheck ：静态C/C++代码分析工具
include-what-you-use ：使用clang进行代码分析的工具，可以#include在C和C++文件中。
OCLint ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。
Clang Static Analyzer：查找C，C++和Objective-C程序bug的源代码分析工具
List of tools for static code analysis ：来自维基百科的静态代码分析工具列表



但必须保证一点：data中得一个或者多个数据必须都是同类型得，不然无法被识别








创建时间：20/10/2016 01:55:58 

添加子概念失败,yuan原因在于----------没有加入kind  》  2001得情况
		/*如果不存在则尝试将该对象加入网络*/
		if (tmpObi == NULL  && conf->addNewObj == 1)
		{


			// do  not add nero for  every  kind  of data
			// there is  bug,where  
			switch(dataKind[i])
			{
				case NeuronNode_ForChCharacter:
				case NeuronNode_ForChWord:
				
						tmpObi=  nero_addNeroByData(DataFlow[i],dataKind[i],GodNero);
						break;
				default:
						



						break;

			}




nero_addNeroByData:default1 ,begin to check childKind  *p=35 ,kind=0,0


在DataFlowProcess中:its time to CreateNewBaseObj,objNum=4,nextBaseKind=2013




2214 空对象或者为基类对象,obtainOrderFromTFF 0: ********order=219*********countOfWord=5,kind=0,0

2241 在DataFlowProcess中:nero_CreateNewBaseObj success,new basekind=2013 !,kind=0,0




2344 空对象或者为基类对象,obtainOrderFromTFF 0: ********order=219*********countOfWord=5,kind=0,0	




2482 空对象或者为基类对象,obtainOrderFromTFF 0: ********order=219*********countOfWord=5,kind=0,0	4




obtainOrderFromTFF2: find dataKind=2012,tff->order=301
nero_IfHasNeuronObjectKindUnknow1:start serch basekind=2012,[21]
nero_IfHasNeuronObjectKindUnknow1:start serch basekind=2012,baseObj=406a8960,[21]


onObjectKindUnknow1:start serch basekind=2012,baseObj=406a8960,[21],


		地址406a89a0,DataNUm2=2,[2,1,]

		空对象或者为基类对象,msg1:在DataFlowProcess中找不到该概念,kind=2012,i=1  str=49,kind=0,0







	
	
		
	
