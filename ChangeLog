ver0.13版本：
创建时间：2014年01月05日 星期日 01时05分52秒 
基本说明：IO  log消息系统框架搭建完成


ver0.14版本：
创建时间：2014年01月05日 星期日 01时05分52秒 
更新说明：
	1:文件层次结构整理
	2:makefile重写
	3:处理数据流水,DataFlowProcess()函数的细化


ver0.16版本：
2014年01月21日 星期二 16时29分07秒 
更新说明：
	1:,DataFlowProcess()函数中加入子集的衍生概念判断与子集合并
	2:
	3:
	2014年01月29日 星期三 15时31分06秒 
	我感觉现在对于实现一个终极的系统来说你连骨架都没有搭建好，只是摆出了一个
	影子而已，因为整个系统的各个部分不仅仅是分工合作的关系还会相互影响
	所以你不要指望一下子就达到某个结果，慢慢来啊
	
ver0.17版本：
创建时间：2014年02月02日 星期日 16时23分23秒 
更新说明：
	1:衍生基类创建
	2:打算在这个版本加入逻辑推理
	3:在系统中加入基本操作
	
	新的开始:
	2014年12月13日 星期六 08时12分48秒 
	2015年07月02日 星期四 10时36分20秒 
	2015年09月23日 星期三 22时47分40秒 

ver0.18版本：
创建时间：14/02/2016 20:21:31 
更新说明：
	1:打算移除gtk
		当前修改位置：neroMain.c   151  24/04/2016 21:54:20 

		当前修改位置：neroMain.c   155  26/04/2016 01:35:33 



	2:下一步是建立方便得查询机制
		查某类得孩子和相关信息
		现在先作简单得程序内部查询，不做程序外面第三方程序查询


	3：对数据流得处理部分继续进行完善。
		1：尝试用大量数据充斥程序，用大量小说充斥词汇量
		2：往一个实用程序靠近---棋牌（优先，主要是考虑逻辑判断和自主学习得能力），文字对话，数学运算，加入一些与计算机功能相关得操作（不考虑）
	
					图像识别。
		在对象层次化方面肯定还有需要加强得地方，还是从实际得功能得实现来逐步加强把。
		先从数学运算开始把：
					。概念输入
					。符号输入
					。规则学习
					。例子学习
					。实际操作检验
	
	
		下一步：规则学习
				因为规则得学习强调层次化得作用，所以Process_ObjForecast(&forecastInfo_st);
				得准确率就非常重要

				人工智能（能力）是智能机器所执行的通常与人类智能有关的智能行为，
				如判断、推理、证明、 、理解、通信、设计、思考、学习核问题求解等思维活动。

				如何实现推理机制
					必须严格定义概念才能进行推理
				如何实现类比机制
					比如说100  101  为百位数，如何推出200也是百位数


				好像都可以用层次化得sys来解释完成，但是都是模糊得





	4：   下一步开始实现  系统运行逻辑记录  中100行后面得东西，考虑到这些东西主观性太强
		还是等一段时间再从新些代码把，冷静以下

			Process_StrengthenLink







创建时间：27/06/2016 16:40:31 

	系统运行逻辑记录 中得1---3要同时实现。

	Process_StrengthenLink		会加强一些类别得联系-》具体指的是短期内出现大量相似数据时，会有机制加强这几个数据积累得联系，
					达到一定程度后形成新得衍生类（需要判断是否需要生成新得衍生类，显然这种类别得形成很可能没有类名）
					必须要强调得是：会到这个函数里面来处理得数据很可能是离散得，没有规律得，甚至数据之间
					没有明显关联得。

					对于临时区域中的概念在以下俩中情况下会对永久区域产生影响：
						1：
						2：出现大量相似数据时，，达到一定程度后形成新类（如果是
							已经有得类别，则不需要这步），同时搜索临时区域，判断其他符合这个类得临时衍生类
							全部写入永久区域中
						3：


	有一个临时区域，短时间内保存一切输入得数据，且 neroConf.addLevelObjAlways=1;

		永远用nero_createObjFromMultiples( objs, objNum);（objNum》1）来形成这些个子类得上层概念，一开始
		没有形成一个新类（或者说是只添加一些临时得链接和上层概念），这样得化				
		已经可以达到	稀疏离散表征	得功能了		

		其实，在没有完全实现新得Process_StrengthenLink函数之前，基本上就因该能够实现 稀疏离散表征 得功能了
		问题在于，在大量数据得输入过程当中如何筛选出真正有关联得对象，这个能力越强，学习得能力和速度就越快。
		再换句话说，Process_StrengthenLink函数就是在实现一个筛选数据得过程，


创建时间：06/07/2016 22:29:27 

	
	Process_StrengthenLink
	第一步：在临时区域（给他一个名字：Staging area）生成一个临时对象（如果发现没有相似同得数据对象时候），如果在永久区域找不到合适得类就
			给他一个临时得kind
		首先判断对象数组是否在临时区域中已经有衍生对象，搜索算法和永远区域算法完全不同。
			关于搜索算法得问题，还需要再次考虑一下，（进入Process_StrengthenLink得前提就是，objs数组，已经无法在永久区域中找到一个完美得
			上层衍生类对象，而且数组得子数组也没有上层对象，这里认为 Process_ObjForecast得结果是理想得）
			在连续多次得输入中，几个子对象可能每次和一些变化得噪音同时出现，是粗糙得直接生成一个新得临时对象
			还是先尝试去掉噪音，
		这里需要判断临时对象得类型，是已知类型，还是未知类型




		断对象数组是否在临时区域中已经有衍生对象得算法如下：
			1：第一次输入时一般总是生成一个新得对象，因为很可能整个临时区域都是空白得（子对象肯定要指向新得临时对象）
			2：后来输入得数据，总会根据数组中得子对象看看是否有指向临时区域得上层概念，如果数据数组中【全部子对象】
				同时指向一个临时对象，且输入顺序是一致得（全部子对象可以是这个上层概念得一部分），则在这个临时对象中加强相关链接强
				度，加强对象链接强度。否则直接生成新得临时衍生对象
				这里主要考虑两个因素：
					1：如果条件太苛刻那么会导致生成大量得临时对象
					2：如果太宽松。。
					3：为如何达到条件生成新得永久对象考虑，必须考虑删除无关数据
					4：仅仅为了进行数据分类考虑得话，你直接全部生成临时类就好了，但是这样无法筛选数据。
					还有一种情况就是这个上层概念得类型，如果是已知类型，即是说数据数组中【部分连续得子对象】指向
					同一个已知类型得上层对象，那么加强这几个对象对概上层对象得链接强度（这样得情况就是当达到一定链接
					强度后可以生成永久对象得例子。），但是，如果数据数组中得子对象都是指向未知类型得上层概念， 那么对不起
					永远无法生成永久对象，直接生成临时衍生对象就好

				你不需要考虑这样处理如何区分分类还是筛选新对象得区别了，因为如果你是在做分类得工作，那么在学习完后，分类得
				数据流得上层类就是无类别的数据，那么往往数据流就是预测最后一个数据。相反得，如果是生成新对象得化，一定是有
				类型得情况，不然怎么生成新对象呢！！

					--------这样做有一个默认得假设是：高级衍生类得基类必须由特殊手段生成，无法在大量得数据流中自动生成。
						这样得花就和我之前想法不一样了，
		这个临时对象和传入Process_StrengthenLink对象数组得关系是：
			子对象在衍生对象得inputlist中
			每一个子对象得outputlist都指向衍生对象
		而在函数nero_createObjFromMultiples  中，衍生对象和子对象得关系是：
			子对象在衍生对象得inputlist中，
			每一个子对象得outputlist都指向衍生对象
			每一个子对象都指向下一个子对象
			
	第二部：调整该对象得强度值（出现次数越多，强度越大）
		后来输入得数据，总会根据数组中得子对象看看是否有指向临时区域得上层概念，如果数据数组中几个子对象
				同时指向一个临时对象，且输入顺序是以至得，则在这个临时对象中加强相关链接强度，
				【削弱不相干得对象链接强度】---这条要不要呢，如果要得话会不会相当于变相删除了
				部分信息，就是说无法进行数据还原了
				------最终决定不要删除这部分数据，因为在分类得过程中，这些数据也是有用得
				
	第三步：强度值达到一定程度后，表明可以将这个对象写入永久区域，但是在这之前必须判断是否将它所表示
		得高级衍生类别（如果是新得话）加入永久区域
		如果它得类是一个临时得kind，就必须判断这个新对象得类别（可能已经有合适得类呢），如果没有
		就生成一个新得类别，（这时候你不需要去搜索其他临时区域中得未满足强度得对象）

		将这个对象写入永久区域则将临时区域中数据取消
		一旦在某次步骤2中，子数组得链接强度达到临界值，就生成一个这个临时对象转移到永久区域中去，同时删除这个临时对象以及
			  相关得链接

	【算法漏洞：如果a，b俩个子对象得出现中间总有不确定得噪音数据做间隔，那么你得算法就无法识别了。】
	进度：-----临时区域（给他一个名字：Staging area）已经完成
			

	             还有一个问题,就是记录链接强度得变量是有个上限值得，如果样本数据量太多，很可能导致数据无法进行分辨
		需要（在学习阶段）有个链接强度得定期减弱机制
		必须先假设不同类别得数据得样本个数是相同得：（在很多机器学习任务中，训练集中可能会存在某个或某些类别下的样本数远大于另一些类别下的样本数目。即类别不平衡，为了使得学习达到更好的效果，因此需要解决该类别不平衡问题。）

			一种解决方案是[定期减弱机制]：
				
				在数据训练过程中，每当一个子对象被识别出来是和一个上层低下相关联时，首先是加强他们得链接强度
			其次，判断子对象得outputlist，减弱但不解除子对象指向得在临时区域中得其他临时对象，这意味着，如果
			该自对象大多数指向一个衍生概念时，会有赢者通吃得效应，相反得，如果，在所有样本中，它所指向得不同得
			上层衍生对象得次数相近时，结果就是永远不会有一个强度特别大得链接出来



		因为当数据量足够大时，每个子对象指向上层概念得链接强度已经表明了该对象对于识别对象得重要性了（就是分类当中得权重概念）
	如果仅仅是为了数据识别和分类，你只要单纯得吧所有数据都输入一遍，要是能够实现遍历全部样本就是更加好了
	但是这个能否识别新得永久对象是不矛盾得，尽管你输入了所有数据，但是肯定只有少部分数据是反复出现得。
	你只要规定，什么样反复出现得数据需要单独提出了形成永久对象




	
	最后，既然是临时对象，必须有遗忘得机制
////////////////////////////////////////////////////////////////////
	还有你呀判断永久子对象指向临时对象后是否会对其他代码产生影响----有影响得，必须一一排除
	////////////////////////////////////////////////////////////////////
	
	
	比如：
	NeuronObject * nero_createObjFromMultiples(NeuronObject *Obis[],nero_s32int objNum)
	中，调用：newObiKind= nero_judgeNewObjKind(Obis, objNum);是否有问题


	还有
	void AddNewObjToForecastList(struct DataFlowForecastInfo  * forecastInfo,NeuronObject * newObj)

	中关于预测链表得更新是直接把所有得outputlist都输入得





创建时间：16/08/2016 22:11:27 


	Process_StrengthenLink已经初步完成,下一步是添加在SAPoool中衍生对象的代码,显然不好直接用函数
nero_createObjFromMultiples,因为它太多地方默认使用了GodNero




创建时间： 15/10/2016 21:32:36 


		建立花得概念---------------在ReadTaskFromTxt生成/////////
	 	--  Iris
       		--  Setosa
      		--  Versicolour
      		--  Virginica	
Attribute Information:
		   1. sepal length in cm		注意这里得意识是iris得子概念是这4个属性，而不是直接得4个数字
		   2. sepal width in cm
		   3. petal length in cm
		   4. petal width in cm

	小数怎么办：
		方法1：都乘以10倍处理，化解小数点	为了加快进度可以这样解决，但是后面在比较相似度时怎么处理
		方法2：建立小数概念


	如果在训练后，进行实验时某个数据未在训练时出现怎么处理
		方法1：进行近似处理，变为出现过得数据进行处理（是说等效处理，而不是真得把实验数据改了）----更合适
		方法2：直接忽略处理


		如果要进行等效处理，就必须建立数得大小比较能力（比较相似度）----暂时设置为sys自带功能，直接给个函数即可


静态代码分析
提高质量，减少瑕疵的代码分析工具列表

Cppcheck ：静态C/C++代码分析工具
include-what-you-use ：使用clang进行代码分析的工具，可以#include在C和C++文件中。
OCLint ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。
Clang Static Analyzer：查找C，C++和Objective-C程序bug的源代码分析工具
List of tools for static code analysis ：来自维基百科的静态代码分析工具列表



但必须保证一点：data中得一个或者多个数据必须都是同类型得，不然无法被识别








创建时间：20/10/2016 01:55:58 


创建时间：29/10/2016 22:08:40 
	对于test数据得分类分俩步走：
	1：只识别和处理所有子类都能识别得obj，进而进行分类
	2：对于不能识别得子类进行分别处理，进而进行分类

	
	完成------------------：
Task_Order_DataSteamInput



创建时间：30/12/2016 19:33:05 


	下一步该怎么做？
		1：将测试数据处理后输入sys，进行类别判断都输出判断得结果，但是不输入sys

		2：在这里你唯一知道得是每次输入得数据是一个待识别类型得数据，它可能在sys已经有具体得实例
		也可能没有具体得实例，如果是后者你无法通过查询来确认数据得类型，必须通过某种具体得比较机制
		来确认数据得类别



		3：分类有俩种方法：一是进行链接得多少，链接越多相似度越高，而是数据本身得相似度，这就涉及数据得比较方法了
		对于iris来说，虽然数据量不大，但是通过链接得多少进行判断也是可以得，
			最好是对两种方法结合起来，就是先进行数据得相似度比较，先将输入得数据进行比较，找出几个相似度较高得上层
		对象
			或者这样，先通过链接得多少来判断相似度，如果根本没有链接，或者链接得结果无法进行判断，就只好先进行数据得
		比较，将数据得数据转化为在sys已经存在得对象，再进行链接得比较
			最终得出一个分类得结果


		那你究竟希望sys输出什么呢？
		就是你输入一组数据，让sys判断最可能得类别，让他输出这个类别




	// 打印obj 输出列表得信息
nero_s32int Log_printNeroObjLinkTree(void * arg)


//////////////////////////////////////////////////////////////////////
2600行的bug处理：
		else
		{
		        // forecastInfo->waitForRecognise=tmpObi;
		        /*让预测列表更新后（加入tmpObi）重新识别一遍tmpObi*/
		        // forecastInfo->waitForRecogniseObjPos=forecastInfo->objPoint-1;
		        // forecastInfo->objPoint=forecastInfo->waitForRecogniseObjPos;
		
		}	

	如果实在处理不了，就先注释掉Process_ObjForecast重新写这部分代码

初始列表
Log_printSomeMsgForObj:msg1:在DataFlowProcess中find概念,kind=62,i=0  str=55

Log_printNeroObjLinkTree:		Kind:2012, address:406a9e20,data=32
Log_printNeroObjLinkTree:		Kind:2012, address:406aa120
地址406aa120,DataNUm2=2,[4,8,]
Log_printNeroObjLinkTree:		Kind:2012, address:406aa120,data=48
Log_printNeroObjLinkTree:		Kind:2012, address:406a9ea0
Log_printNeroObjLinkTree:		Kind:2012, address:406aa140
Log_printNeroObjLinkTree:		Kind:61, address:406a7c40
Log_printNeroObjLinkTree:		Kind:2012, address:406f2fe0

get _Strengthen===nodeobj=406f3fe0
AddNodeIntoForecastList:预测链表增长,kind=2012,add=406f3fe0   ,DataNUm2=1,[2,]

AddNewObjToForecast:kind=2012,add=40701a40,point to add:40701b00

Log_printNeroObjLinkTree:		Kind:2012, address:40701f60
Log_printNeroObjLinkTree:		Kind:61, address:406ffa80




创建时间：03/01/2017 16:28:44 
		调试发现，使用Task_Order_DataSteamInput时
	以数据310 55 42 14 2为例，前面4个数据可以被识别为NeuronNode_ForChWord
                    if(lenOfpar == 1)
                        dataKind[k] = NeuronNode_ForChCharacter;
                    else
                        dataKind[k] = NeuronNode_ForChWord;
	见代码task.c 773页




创建时间：04/01/2017 00:36:35 


	第一次的分类结果出来了，完全没有准确度啊

创建时间：18/02/2017 23:43:00 

	尝试修改第一次分类的算法

	首先你需要详细分析（单次）分类的过程中的数据，找到提升准确率的方法



	1：打印所有的
		203 setosa
		203 versicolor
		203 virginica

		类型对象的实例
	2：输出每次匹配时匹配到的对象
		先确认一下进行比较前，test数据实例的最终kind是什么：

		你会发现如果输入一个62的数据，如果该数据在62中没有，而2012中有，那么找到的就是一个2012的数据
		因为2012和62的数据类型格式是一样的，所以如果不知道目标的准确类型则会出现混淆
		---之所以会出现这样的结果，是因为在函数nero_StrengthenLinkWithK中将反复出现的链接前移的结果 

		为了让比较的数据类型与实际的同步，你需要在比较前先判断数据数据的类型，如果需要时可以进行修改
		或者说转为你需要的类型obj再进行比较

		也就是说，你用nero_IfHasNeuronObject找出来的虽然可能是最可能的对象，但也可能不是你想要的，需要调整

	-----就是需要加入反馈机制

		1：首先修正objs[]
		2：再次运行

、

创建时间：08/04/2017 22:49:24 
		发现修改了objs[]后的准确率并没有提高


在函数中，关于        newListNode->Strengthen=FiberStrengthen;的做法是否正确---没问题，
void AddNodeIntoForecastList(struct list_head  * listHead,NeuronObject * Obj,nero_us32int  FiberStrengthen)


现在的问题是：这里是否要加入修改findNodeINlist->Strengthen

            else
            {
                    /*对于刚被查询的概念，就是新输入的，但是列表中
                    已经有的概念延长起存在时间，已避免反复添加删除
                    */
                    
                    (findNodeINlist->times)--;
/*                                        printf("findNodeINlist->times=%d.\n",findNodeINlist->times);*/
                    
            }


Log_printNeroObjLink[高级衍生类]:


2017-04-09 ：

	你发现问题的关键在于你没有一个反馈机制，或者说一个自动交互机制
	但你现在可以先把这个机制放一放先，先找一个临时的办法解决一下，以后再说
	现在是关键看你的这个算法能否有一定的准确率



	现在的大的bug暂时没有发现，但是，你算法的缺陷导致2014,2015的准确率不如2013
	就是你的所有4项数据都是混在一起的，没有进行区分，这样影响了准确率

	但是这扯出来一个问题，就是sys什么时候自动判断是时候需要生成一个新类来定义一个子数据项了
	目前，你是在主动定义子数据项的。



2017-04-10 	：

	下一步怎么做呢？

	选择1：继续做adult的分类测试  ----稳健点
	选择2：循环类的代码编写，再进行加减法的测试，再进行操作类的代码编写



	继续做adult的分类测试:
		先考虑俩个问题，1：做监督学习还是无监督学习
			必须是监督学习啊，因为你的sys本质上是一个记忆系统，并没有一套自动归类的算法体系
				2：做成一个数据流预测，还是分类、
			表面上看，你的这个adult数据集非常适合做成数据流预测，但是还是做成分类比较合适
			什么是真正的数据流预测，就是那种在无止境的，完全没有数据流数据间隔标记的，完全无序（但绝对有规律）的数据流的预测
			（比如说游戏数据的数据流，是无序的，但绝对是有规律的，）



		你可以预想一个问题：如果你要做一个数据流的预测，应该是什么形式
			首先是数据的定义，是全部定义成一个类型呢，还是多个类型
			其次，是数据怎么保存，怎么链接


		显然，以游戏数据的数据流为例，其实这里面的数据分为2类，1类是游戏系统的数据输出
		2类是人类给游戏的数据输入，本质是，什么样的游戏输出将导致什么样合适的游戏数据输入
	

		换句话说，尽管这俩种数据是相互影响的，但是抽象来说，还是可以进行这样抽象的：
					数据A   ---》  操作X

					数据B  ----》   操作Y

		也就是说，这里所谓的数据流其实是多个obj的集合

		当然你还需要一个评价的机制，来判断，哪些数据集合是你所希望的，哪些是不希望的，这样sys
		才能有选择的进行输出
			数据A   ---》  操作X  ---》  评价  M
			数据B  ----》   操作Y  ---》  评价  N


			-------发现没有，这里可以抽象成3个basekind  ： 数据 kind，操作kind，结果kind
		显然，数据 kind，操作kind  其实都是结果kind的数据
		-----------------------------------------------------------结论就是，统一为分类了
				



	继续做adult的分类测试  

		
		1：怎么进行basekind生成，显然你的basekind的生成需要注明你data是可以缺失的
			在输入的输入形式上只有DataFlow【i】为NULL就表示缺失
		2：每一个数据项，必须单独生成basekind
		3：在正式数据输入之前，你需要先确保sys中已经有这些子数据的obj  （这样可以避免test数据输入时在sys没有该数据时需要进行数据比较了）
		4：Kind:61,actual num:6835 ,record  num:6835
			关于kind  61，其中的数据到底是怎么样的是否包括了英文字母

		
		



















	
	
		
	
