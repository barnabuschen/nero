ver0.13版本：
创建时间：2014年01月05日 星期日 01时05分52秒 
基本说明：IO  log消息系统框架搭建完成


ver0.14版本：
创建时间：2014年01月05日 星期日 01时05分52秒 
更新说明：
	1:文件层次结构整理
	2:makefile重写
	3:处理数据流水,DataFlowProcess()函数的细化


ver0.16版本：
2014年01月21日 星期二 16时29分07秒 
更新说明：
	1:,DataFlowProcess()函数中加入子集的衍生概念判断与子集合并
	2:
	3:
	2014年01月29日 星期三 15时31分06秒 
	我感觉现在对于实现一个终极的系统来说你连骨架都没有搭建好，只是摆出了一个
	影子而已，因为整个系统的各个部分不仅仅是分工合作的关系还会相互影响
	所以你不要指望一下子就达到某个结果，慢慢来啊
	
ver0.17版本：
创建时间：2014年02月02日 星期日 16时23分23秒 
更新说明：
	1:衍生基类创建
	2:打算在这个版本加入逻辑推理
	3:在系统中加入基本操作
	
	新的开始:
	2014年12月13日 星期六 08时12分48秒 
	2015年07月02日 星期四 10时36分20秒 
	2015年09月23日 星期三 22时47分40秒 

ver0.18版本：
创建时间：14/02/2016 20:21:31 
更新说明：
	1:打算移除gtk
		当前修改位置：neroMain.c   151  24/04/2016 21:54:20 

		当前修改位置：neroMain.c   155  26/04/2016 01:35:33 



	2:下一步是建立方便得查询机制
		查某类得孩子和相关信息
		现在先作简单得程序内部查询，不做程序外面第三方程序查询


	3：对数据流得处理部分继续进行完善。
		1：尝试用大量数据充斥程序，用大量小说充斥词汇量
		2：往一个实用程序靠近---棋牌（优先，主要是考虑逻辑判断和自主学习得能力），文字对话，数学运算，加入一些与计算机功能相关得操作（不考虑）
	
					图像识别。
		在对象层次化方面肯定还有需要加强得地方，还是从实际得功能得实现来逐步加强把。
		先从数学运算开始把：
					。概念输入
					。符号输入
					。规则学习
					。例子学习
					。实际操作检验
	
	
		下一步：规则学习
				因为规则得学习强调层次化得作用，所以Process_ObjForecast(&forecastInfo_st);
				得准确率就非常重要

				人工智能（能力）是智能机器所执行的通常与人类智能有关的智能行为，
				如判断、推理、证明、 、理解、通信、设计、思考、学习核问题求解等思维活动。

				如何实现推理机制
					必须严格定义概念才能进行推理
				如何实现类比机制
					比如说100  101  为百位数，如何推出200也是百位数


				好像都可以用层次化得sys来解释完成，但是都是模糊得





	4：   下一步开始实现  系统运行逻辑记录  中100行后面得东西，考虑到这些东西主观性太强
		还是等一段时间再从新些代码把，冷静以下

			Process_StrengthenLink







创建时间：27/06/2016 16:40:31 

	系统运行逻辑记录 中得1---3要同时实现。

	Process_StrengthenLink		会加强一些类别得联系-》具体指的是短期内出现大量相似数据时，会有机制加强这几个数据积累得联系，
					达到一定程度后形成新得衍生类（需要判断是否需要生成新得衍生类，显然这种类别得形成很可能没有类名）
					必须要强调得是：会到这个函数里面来处理得数据很可能是离散得，没有规律得，甚至数据之间
					没有明显关联得。

					对于临时区域中的概念在以下俩中情况下会对永久区域产生影响：
						1：
						2：出现大量相似数据时，，达到一定程度后形成新类（如果是
							已经有得类别，则不需要这步），同时搜索临时区域，判断其他符合这个类得临时衍生类
							全部写入永久区域中
						3：


	有一个临时区域，短时间内保存一切输入得数据，且 neroConf.addLevelObjAlways=1;

		永远用nero_createObjFromMultiples( objs, objNum);（objNum》1）来形成这些个子类得上层概念，一开始
		没有形成一个新类（或者说是只添加一些临时得链接和上层概念），这样得化				
		已经可以达到	稀疏离散表征	得功能了		

		其实，在没有完全实现新得Process_StrengthenLink函数之前，基本上就因该能够实现 稀疏离散表征 得功能了
		问题在于，在大量数据得输入过程当中如何筛选出真正有关联得对象，这个能力越强，学习得能力和速度就越快。
		再换句话说，Process_StrengthenLink函数就是在实现一个筛选数据得过程，


创建时间：06/07/2016 22:29:27 

	
	Process_StrengthenLink
	第一步：在临时区域（给他一个名字：Staging area）生成一个临时对象（如果发现没有相似同得数据对象时候），如果在永久区域找不到合适得类就
			给他一个临时得kind
		首先判断对象数组是否在临时区域中已经有衍生对象，搜索算法和永远区域算法完全不同。
			关于搜索算法得问题，还需要再次考虑一下，（进入Process_StrengthenLink得前提就是，objs数组，已经无法在永久区域中找到一个完美得
			上层衍生类对象，而且数组得子数组也没有上层对象，这里认为 Process_ObjForecast得结果是理想得）
			在连续多次得输入中，几个子对象可能每次和一些变化得噪音同时出现，是粗糙得直接生成一个新得临时对象
			还是先尝试去掉噪音，
		这里需要判断临时对象得类型，是已知类型，还是未知类型




		断对象数组是否在临时区域中已经有衍生对象得算法如下：
			1：第一次输入时一般总是生成一个新得对象，因为很可能整个临时区域都是空白得（子对象肯定要指向新得临时对象）
			2：后来输入得数据，总会根据数组中得子对象看看是否有指向临时区域得上层概念，如果数据数组中几个子对象
				同时指向一个临时对象，且输入顺序是以至得，则在这个临时对象中加强相关链接强度，削弱不相干得对象链接强度
			
		这个临时对象和传入Process_StrengthenLink对象数组得关系是：
			子对象在衍生对象得inputlist中
			每一个子对象得outputlist都指向衍生对象
		而在函数nero_createObjFromMultiples  中，衍生对象和子对象得关系是：
			子对象在衍生对象得inputlist中，
			每一个子对象得outputlist都指向衍生对象
			每一个子对象都指向下一个子对象
			
	第二部：调整该对象得强度值（出现次数越多，强度越大）
		后来输入得数据，总会根据数组中得子对象看看是否有指向临时区域得上层概念，如果数据数组中几个子对象
				同时指向一个临时对象，且输入顺序是以至得，则在这个临时对象中加强相关链接强度，
				【削弱不相干得对象链接强度】---这条要不要呢，如果要得话会不会相当于变相删除了
				部分信息，就是说无法进行数据还原了
				------最终决定不要删除这部分数据，因为在分类得过程中，这些数据也是有用得
				
	第三步：强度值达到一定程度后，表明可以将这个对象写入永久区域，但是在这之前必须判断是否将它所表示
		得高级衍生类别（如果是新得话）加入永久区域
		如果它得类是一个临时得kind，就必须判断这个新对象得类别（可能已经有合适得类呢），如果没有
		就生成一个新得类别，（这时候你不需要去搜索其他临时区域中得未满足强度得对象）

		将这个对象写入永久区域则将临时区域中数据取消
		一旦在某次步骤2中，子数组得链接强度达到临界值，就生成一个这个临时对象转移到永久区域中去，同时删除这个临时对象以及
			  相关得链接

	【算法漏洞：如果a，b俩个子对象得出现中间总有不确定得噪音数据做间隔，那么你得算法就无法识别了。】
	进度：-----临时区域（给他一个名字：Staging area）已经完成


	             -----Process_StrengthenLink12/08/2016 21:37:43 


14/08/2016 00:52:53 










	
	
	
	
	
	
		
	
